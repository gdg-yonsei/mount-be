## 구현사항
* 폴더 생성 API
* 이름 변경 API
* 특정 폴더에 포함된 파일/폴더 메타데이터 반환 API
* (고려) 폴더 삭제 API
* (고려) 폴더/파일 이동 API

## 중점 고민 사항
### 파일 시스템 구조
* Tree 구조 사용
    - parent_id 저장

* 폴더와 파일이 server에 저장되는 방식
    - 파일: UUID.확장자 
    - 폴더: 메타데이터(서버에 저장 X)

    - 서버에 저장되는 데이터는 파일 그 자체의 내용이 핵심, 유지/삭제 뿐 (파일편집기를 지원한다면 달라질수도?...)
    - 사용자에게 폴더 구조로 파일을 저장할 수 있게 하더라도, 서버에서 해당 구조를 따를 필요는 없음
        -> 물리적으로 폴더가 존재할 필요가 없고 메타데이터로 파일의 계층 구조를 표현할 수 있음


### child_list field 추가에 대한 고민
- 저장하지 않을 때 추가 연산 필요
    user_id의 모든 폴더/파일.parent_folder = folder_id 

* child_list의 유용성?
    - 하위 파일/폴더의 메타데이터 반환 api
    - 폴더 삭제 api

* child_list의 단점?
    - 모든 row가 child_list를 가져야 함 -> 저장공간요구량 up
        - 해당 프로젝트에서는 큰 영향 없을듯함
    - child_list field의 가변적 크기
    - update가 많아짐 (하위폴더/파일의 생성/삭제)

* 최종 선택: parent_id만 사용
    - update 최소화
    - 빠른 구현 추구

* 폴더 삭제 api에서의 성능이 얼마나 보장되는지 테스트해볼 필요성이 있음
* 내가 클라우드 서비스를 사용할 때 매번 폴더를 들락날락했는데, 그렇다면 메타데이터 반환 api 요청이 다수일텐데 child_list를 넣는게 좋을 것 같기도 하다. 테스트 필요

### 파일/폴더의 id 검색에 대한 고민
* 파일/폴더의 path는 정확하게 요청된다고 가정
* A/x.txt가 존재할 때, B/x.txt가 존재할 수 있다. => 이름뿐만이 아닌 path를 고려한 api를 설계해야함
    - 이 가능성을 생각하니 api를 통해 전달되는 original file name만으로 폴더나 파일을 특정할 수 없었고 path의 계층을 하나씩 확인해주어야하는 번거로움이 생겼다. ...
    - 폴더나 파일에 대하여 계층의 가장 하위 폴더(path의 가장 마지막)의 id를 parent_id라고 하고
        1) path에서 parent_id를 찾음
        2) parent_id를 통한 폴더/파일을 특정하여 metadata를 불러옴
        의 과정으로 대부분의 함수를 구현했는데 어떤 자료구조/메타데이터를 사용해야 더 간결한 코드가 될지에 대한 고민이 들었다.
* File에 folder_id 필드 추가

### Notes
* 여러모로 로그인한 유저의 전체 폴더/파일의 메타데이터를 불러두면 좋을 것 같다는 생각을 했다. 